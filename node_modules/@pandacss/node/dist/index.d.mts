import * as _pandacss_reporter from '@pandacss/reporter';
import { ReportFormat } from '@pandacss/reporter';
import * as _pandacss_types from '@pandacss/types';
import { LoadConfigResult, Artifact, Runtime, PandaHooks, WatchOptions, WatcherEventType, AnalysisOptions, ArtifactId, Config, CssArtifactType } from '@pandacss/types';
import { StyleEncoder, Stylesheet } from '@pandacss/core';
import { Generator } from '@pandacss/generator';
import * as _pandacss_parser from '@pandacss/parser';
import { Project, ParserResult } from '@pandacss/parser';
import { Root, Message } from 'postcss';

declare class DiffEngine {
    private ctx;
    private prevConfig;
    constructor(ctx: Generator);
    /**
     * Reload config from disk and refresh the context
     */
    reloadConfigAndRefreshContext(fn?: (conf: LoadConfigResult) => void): Promise<_pandacss_types.DiffConfigResult>;
    /**
     * Update the context from the refreshed config
     * then persist the changes on each affected engines
     * Returns the list of affected artifacts/engines
     */
    refresh(conf: LoadConfigResult, fn?: (conf: LoadConfigResult) => void): _pandacss_types.DiffConfigResult;
}

interface OutputEngineOptions extends Generator {
    runtime: Runtime;
    hooks: Partial<PandaHooks>;
}
declare class OutputEngine {
    private paths;
    private fs;
    private path;
    constructor(options: OutputEngineOptions);
    empty: () => void;
    ensure: (file: string, cwd: string) => string;
    write: (output: Artifact | undefined) => Promise<PromiseSettledResult<void>[]> | undefined;
}

declare class PandaContext extends Generator {
    runtime: Runtime;
    project: Project;
    output: OutputEngine;
    diff: DiffEngine;
    explicitDeps: string[];
    constructor(conf: LoadConfigResult);
    private getExplicitDependencies;
    initMessage: () => string;
    getFiles: () => string[];
    parseFile: (filePath: string, styleEncoder?: StyleEncoder) => ParserResult | undefined;
    parseFiles: (styleEncoder?: StyleEncoder) => {
        filesWithCss: string[];
        files: string[];
        results: ParserResult[];
    };
    writeCss: (sheet?: Stylesheet) => Promise<PromiseSettledResult<void>[]> | undefined;
    watchConfig: (cb: (file: string) => void | Promise<void>, opts?: Omit<WatchOptions, "include">) => void;
    watchFiles: (cb: (event: WatcherEventType, file: string) => void | Promise<void>, opts?: Omit<WatchOptions, "include" | "exclude" | "poll" | "cwd" | "logger">) => void;
}

declare function analyze(ctx: PandaContext, options?: AnalysisOptions): {
    getRecipeReport(format?: ReportFormat): {
        report: _pandacss_reporter.RecipeReportEntry[];
        formatted: string;
    };
    getTokenReport(format?: ReportFormat): {
        report: _pandacss_reporter.TokenAnalysisReport;
        formatted: string;
    };
    writeReport(filePath: string): Promise<void>;
};

declare function buildInfo(ctx: PandaContext, outfile: string): Promise<void>;

declare class Builder {
    /**
     * The current panda context
     */
    context: PandaContext | undefined;
    private hasEmitted;
    private filesMeta;
    private explicitDepsMeta;
    private affecteds;
    private configDependencies;
    setConfigDependencies(options: SetupContextOptions): void;
    setup: (options?: {
        configPath?: string;
        cwd?: string;
    }) => Promise<PandaContext | undefined>;
    emit(): Promise<void>;
    setupContext: (options: SetupContextOptions) => Promise<PandaContext>;
    getContextOrThrow: () => PandaContext;
    getFileMeta: (file: string) => {
        mtime: number;
        isUnchanged: boolean;
    };
    checkFilesChanged(files: string[]): {
        changes: Map<string, FileMeta>;
        hasFilesChanged: boolean;
    };
    extractFile: (ctx: PandaContext, file: string) => _pandacss_parser.ParserResult | undefined;
    extract: () => void;
    isValidRoot: (root: Root) => boolean;
    write: (root: Root) => void;
    registerDependency: (fn: (dep: Message) => void) => void;
}
interface FileMeta {
    mtime: number;
    isUnchanged: boolean;
}
interface SetupContextOptions {
    configPath: string;
    cwd?: string;
}

declare function codegen(ctx: PandaContext, ids?: ArtifactId[]): Promise<{
    box: string;
    msg: string;
}>;

declare function loadConfigAndCreateContext(options?: {
    cwd?: string;
    config?: Config;
    configPath?: string;
}): Promise<PandaContext>;

declare const startProfiling: (cwd: string, prefix: string, isWatching?: boolean) => Promise<(cb?: () => void) => void>;

interface CssGenOptions {
    cwd: string;
    outfile?: string;
    type?: CssArtifactType;
    minimal?: boolean;
}
declare const cssgen: (ctx: PandaContext, options: CssGenOptions) => Promise<void>;

interface DebugOptions {
    outdir: string;
    dry: boolean;
    onlyConfig?: boolean;
}
declare function debug(ctx: PandaContext, options: DebugOptions): Promise<void>;

declare function generate(config: Config, configPath?: string): Promise<void>;

declare function setupGitIgnore(ctx: PandaContext): void;

interface LogstreamOptions {
    cwd?: string;
    logfile?: string;
}
declare const setLogStream: (options: LogstreamOptions) => {
    end(): void;
    [Symbol.dispose]: () => void;
};

declare function parseDependency(fileOrGlob: string): Message | null;

type SetupOptions = Partial<Config> & {
    force?: boolean;
};
declare function setupConfig(cwd: string, opts?: SetupOptions): Promise<void>;
declare function setupPostcss(cwd: string): Promise<void>;

export { Builder, type CssGenOptions, PandaContext, analyze, buildInfo, codegen, cssgen, debug, generate, loadConfigAndCreateContext, parseDependency, setLogStream, setupConfig, setupGitIgnore, setupPostcss, startProfiling };
