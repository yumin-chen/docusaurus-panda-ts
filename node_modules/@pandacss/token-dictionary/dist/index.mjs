// src/dictionary.ts
import {
  capitalize,
  compact,
  cssVar,
  esc as esc3,
  isString as isString2,
  mapObject,
  memo,
  walkObject as walkObject2
} from "@pandacss/shared";
import { isMatching as isMatching2, match as match2 } from "ts-pattern";

// src/is-composite.ts
import { P, isMatching } from "ts-pattern";
var isCompositeShadow = isMatching({
  inset: P.optional(P.boolean),
  offsetX: P.union(P.number, P.string),
  offsetY: P.union(P.number, P.string),
  blur: P.union(P.number, P.string),
  spread: P.union(P.number, P.string),
  color: P.string
});
var isCompositeGradient = isMatching({
  type: P.string,
  placement: P.string,
  stops: P.union(
    P.array(P.string),
    P.array({
      color: P.string,
      position: P.number
    })
  )
});
var isCompositeBorder = isMatching({
  color: P.string,
  width: P.union(P.string, P.number),
  style: P.string
});
var isCompositeAsset = isMatching({
  type: P.union("url", "svg"),
  value: P.string
});
var isCompositeTokenValue = (value) => {
  return isCompositeGradient(value) || isCompositeShadow(value) || isCompositeBorder(value) || isCompositeAsset(value) || Array.isArray(value);
};

// src/middleware.ts
import { calc, toPx } from "@pandacss/shared";

// src/token.ts
import { isBaseCondition, toHash, walkObject } from "@pandacss/shared";

// src/utils.ts
import { logger } from "@pandacss/logger";
import { PandaError, esc, isObject } from "@pandacss/shared";
var REFERENCE_REGEX = /({([^}]*)})/g;
var curlyBracketRegex = /[{}]/g;
function getReferences(value) {
  if (typeof value !== "string")
    return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches)
    return [];
  return matches.map((match3) => match3.replace(curlyBracketRegex, "")).map((value2) => value2.trim());
}
var hasReference = (value) => REFERENCE_REGEX.test(value);
var tokenFunctionRegex = /token\(([^)]+)\)/g;
var closingParenthesisRegex = /\)$/g;
var hasTokenReference = (str) => str.includes("token(");
var tokenReplacer = (a, b) => b ? a.endsWith(")") ? a.replace(closingParenthesisRegex, `, ${b})`) : `var(${a}, ${b})` : a;
var notFoundMessage = (key, value) => `Reference not found: \`${key}\` in "${value}"`;
var isTokenReference = (v) => hasReference(v) || hasTokenReference(v);
function expandReferences(value, fn) {
  if (!isTokenReference(value))
    return value;
  const references = getReferences(value);
  const expanded = references.reduce((valueStr, key) => {
    const resolved = fn(key);
    if (!resolved) {
      logger.warn("token", notFoundMessage(key, value));
    }
    const expandedValue = resolved ?? esc(key);
    return valueStr.replace(`{${key}}`, expandedValue);
  }, value);
  if (!expanded.includes(`token(`))
    return expanded;
  return expanded.replace(tokenFunctionRegex, (_, token) => {
    const [tokenValue, tokenFallback] = token.split(",").map((s) => s.trim());
    const result = [tokenValue, tokenFallback].filter(Boolean).map((key) => {
      const resolved = fn(key);
      if (!resolved && isTokenReference(key)) {
        logger.warn("token", notFoundMessage(key, value));
      }
      return resolved ?? esc(key);
    });
    if (result.length > 1) {
      const [a, b] = result;
      return tokenReplacer(a, b);
    }
    return tokenReplacer(result[0]);
  });
}
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
var isToken = (value) => {
  return isObject(value) && "value" in value;
};
function assertTokenFormat(token) {
  if (!isToken(token)) {
    throw new PandaError("INVALID_TOKEN", `Invalid token format: ${JSON.stringify(token)}`);
  }
}

// src/token.ts
var Token = class _Token {
  name;
  value;
  originalValue;
  path;
  type;
  description;
  deprecated;
  extensions;
  constructor(input) {
    this.name = input.name;
    this.value = input.value;
    this.originalValue = input.value;
    this.path = input.path ?? [];
    if (input.type) {
      this.type = input.type;
    }
    if (input.description) {
      this.description = input.description;
    }
    this.extensions = input.extensions ?? {};
    this.extensions.condition = input.extensions?.condition ?? "base";
    this.deprecated = input.deprecated;
    this.setType();
  }
  /**
   * The unique identifier of the token.
   */
  get id() {
    return toHash(`${this.name}-${this.extensions.condition}-${this.value}`);
  }
  /**
   * Whether the token is a conditional token.
   * Conditional tokens are tokens that have multiple values based on a condition.
   */
  get isConditional() {
    return !!this.extensions?.conditions;
  }
  /**
   * Whether the token has a reference in its value.
   * e.g. {color.gray.100}
   */
  get hasReference() {
    return !!this.extensions?.references;
  }
  /**
   * Whether the token is a complex or composite token.
   */
  get isComposite() {
    return isCompositeTokenValue(this.originalValue);
  }
  /**
   * Returns the token value with the references expanded.
   * e.g. {color.gray.100} => var(--colors-gray-100)
   *
   */
  expandReferences() {
    if (!this.hasReference)
      return this.extensions.varRef ?? this.value;
    const references = this.extensions.references ?? {};
    this.value = Object.keys(references).reduce((valueStr, key) => {
      const referenceToken = references[key];
      if (referenceToken.isConditional) {
        return valueStr;
      }
      const value = referenceToken.expandReferences();
      return valueStr.replace(`{${key}}`, value);
    }, this.value);
    delete this.extensions.references;
    return this.value;
  }
  /**
   * Whether this token has a reference to another token
   */
  get isReference() {
    return hasReference(this.originalValue);
  }
  /**
   * Returns the list of references in the token value
   */
  get references() {
    return getReferences(this.originalValue);
  }
  clone() {
    return new _Token({
      name: this.name,
      value: this.value,
      type: this.type,
      path: [...this.path],
      description: this.description,
      extensions: cloneDeep(this.extensions)
    });
  }
  /**
   * Returns an array of tokens per conditions.
   * It is commonly used in semantic tokens, and can have multiple values based on a condition.
   * e.g. primary: { light: '#000', dark: '#fff' }
   */
  getConditionTokens() {
    if (!this.isConditional)
      return;
    const conditions = this.extensions.conditions ?? {};
    const conditionalTokens = [];
    walkObject(conditions, (value, path) => {
      const newPath = path.filter((v) => !isBaseCondition(v));
      if (!newPath.length)
        return;
      const token = this.clone();
      token.value = value;
      token.extensions.condition = newPath.join(":");
      conditionalTokens.push(token);
    });
    return conditionalTokens;
  }
  /**
   * Add more extensions to the token
   */
  setExtensions(extensions) {
    this.extensions = { ...this.extensions, ...extensions };
    this.setType();
    return this;
  }
  setType() {
    if (this.type)
      return;
    if (this.extensions.category) {
      this.type = TOKEN_TYPES[this.extensions.category];
    }
  }
};
function cloneDeep(value) {
  if (value instanceof Token) {
    return value.clone();
  }
  if (Array.isArray(value)) {
    return value.map((child) => cloneDeep(child));
  }
  if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, cloneDeep(v)]));
  }
  return value;
}
var TOKEN_TYPES = {
  colors: "color",
  spacing: "dimension",
  sizing: "dimension",
  shadows: "shadow",
  fonts: "fontFamily",
  fontSizes: "fontSize",
  fontWeights: "fontWeight",
  letterSpacings: "letterSpacing",
  durations: "duration",
  transitions: "transition",
  radii: "borderRadius",
  gradients: "gradient",
  easings: "cubicBezier",
  borders: "border",
  borderWidths: "borderWidth",
  components: "cti",
  assets: "asset",
  aspectRatios: "aspectRatio",
  cursor: "cursor"
};

// src/middleware.ts
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix, hash } = dictionary;
    const tokens = dictionary.filter({
      extensions: { category: "spacing" }
    });
    tokens.forEach((token) => {
      const originalPath = [...token.path];
      const originalVar = dictionary.formatCssVar(originalPath, { prefix, hash });
      if (token.value === "0rem") {
        return;
      }
      const node = token.clone();
      node.setExtensions({
        isNegative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      node.value = calc.negate(originalVar);
      const last = node.path.at(-1);
      if (last != null) {
        node.path[node.path.length - 1] = `-${last}`;
      }
      if (node.path) {
        node.name = dictionary.formatTokenName(node.path);
      }
      dictionary.registerToken(node);
    });
  }
};
var units = /* @__PURE__ */ new Set(["spacing", "sizes", "borderWidths", "fontSizes", "radii"]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.isNegative;
    });
    tokens.forEach((token) => {
      token.setExtensions({
        pixelValue: toPx(token.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.filter({ extensions: { category: "colors" } });
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette, colorPaletteRoots, colorPaletteTokenKeys } = token.extensions;
      if (!colorPalette)
        return;
      colorPaletteTokenKeys.forEach((keyPath) => {
        keys.set(dictionary.formatTokenName(keyPath), keyPath);
      });
      colorPaletteRoots.forEach((colorPaletteRoot) => {
        const formated = dictionary.formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(formated) || [];
        colorPaletteList.push(token);
        colorPalettes.set(formated, colorPaletteList);
        if (token.extensions.isDefault && colorPaletteRoot.length === 1) {
          const keyPath = colorPaletteTokenKeys[0]?.filter(Boolean);
          if (!keyPath.length)
            return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(dictionary.formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const node = new Token({
        name: dictionary.formatTokenName(["colors", "colorPalette", ...segments].filter(Boolean)),
        value: dictionary.formatTokenName(["colors", "colorPalette", ...segments].filter(Boolean)),
        path: ["colors", "colorPalette", ...segments]
      });
      node.setExtensions({
        category: "colors",
        prop: dictionary.formatTokenName(["colorPalette", ...segments].filter(Boolean)),
        isVirtual: true
      });
      dictionary.registerToken(node, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter((token) => token.value !== "");
  }
};
var middlewares = [addNegativeTokens, addVirtualPalette, removeEmptyTokens, addPixelUnit];

// src/transform.ts
import { isCssUnit, isString } from "@pandacss/shared";
import { P as P2, match } from "ts-pattern";

// src/mini-svg-uri.ts
var shorterNames = {
  aqua: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  azure: /#f0ffff(ff)?(?!\w)/gi,
  beige: /#f5f5dc(ff)?(?!\w)/gi,
  bisque: /#ffe4c4(ff)?(?!\w)/gi,
  black: /#000000(ff)?(?!\w)|#000(f)?(?!\w)/gi,
  blue: /#0000ff(ff)?(?!\w)|#00f(f)?(?!\w)/gi,
  brown: /#a52a2a(ff)?(?!\w)/gi,
  coral: /#ff7f50(ff)?(?!\w)/gi,
  cornsilk: /#fff8dc(ff)?(?!\w)/gi,
  crimson: /#dc143c(ff)?(?!\w)/gi,
  cyan: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
  darkblue: /#00008b(ff)?(?!\w)/gi,
  darkcyan: /#008b8b(ff)?(?!\w)/gi,
  darkgrey: /#a9a9a9(ff)?(?!\w)/gi,
  darkred: /#8b0000(ff)?(?!\w)/gi,
  deeppink: /#ff1493(ff)?(?!\w)/gi,
  dimgrey: /#696969(ff)?(?!\w)/gi,
  gold: /#ffd700(ff)?(?!\w)/gi,
  green: /#008000(ff)?(?!\w)/gi,
  grey: /#808080(ff)?(?!\w)/gi,
  honeydew: /#f0fff0(ff)?(?!\w)/gi,
  hotpink: /#ff69b4(ff)?(?!\w)/gi,
  indigo: /#4b0082(ff)?(?!\w)/gi,
  ivory: /#fffff0(ff)?(?!\w)/gi,
  khaki: /#f0e68c(ff)?(?!\w)/gi,
  lavender: /#e6e6fa(ff)?(?!\w)/gi,
  lime: /#00ff00(ff)?(?!\w)|#0f0(f)?(?!\w)/gi,
  linen: /#faf0e6(ff)?(?!\w)/gi,
  maroon: /#800000(ff)?(?!\w)/gi,
  moccasin: /#ffe4b5(ff)?(?!\w)/gi,
  navy: /#000080(ff)?(?!\w)/gi,
  oldlace: /#fdf5e6(ff)?(?!\w)/gi,
  olive: /#808000(ff)?(?!\w)/gi,
  orange: /#ffa500(ff)?(?!\w)/gi,
  orchid: /#da70d6(ff)?(?!\w)/gi,
  peru: /#cd853f(ff)?(?!\w)/gi,
  pink: /#ffc0cb(ff)?(?!\w)/gi,
  plum: /#dda0dd(ff)?(?!\w)/gi,
  purple: /#800080(ff)?(?!\w)/gi,
  red: /#ff0000(ff)?(?!\w)|#f00(f)?(?!\w)/gi,
  salmon: /#fa8072(ff)?(?!\w)/gi,
  seagreen: /#2e8b57(ff)?(?!\w)/gi,
  seashell: /#fff5ee(ff)?(?!\w)/gi,
  sienna: /#a0522d(ff)?(?!\w)/gi,
  silver: /#c0c0c0(ff)?(?!\w)/gi,
  skyblue: /#87ceeb(ff)?(?!\w)/gi,
  snow: /#fffafa(ff)?(?!\w)/gi,
  tan: /#d2b48c(ff)?(?!\w)/gi,
  teal: /#008080(ff)?(?!\w)/gi,
  thistle: /#d8bfd8(ff)?(?!\w)/gi,
  tomato: /#ff6347(ff)?(?!\w)/gi,
  violet: /#ee82ee(ff)?(?!\w)/gi,
  wheat: /#f5deb3(ff)?(?!\w)/gi,
  white: /#ffffff(ff)?(?!\w)|#fff(f)?(?!\w)/gi
};
var REGEX = {
  whitespace: /\s+/g,
  urlHexPairs: /%[\dA-F]{2}/g,
  quotes: /"/g
};
function collapseWhitespace(str) {
  return str.trim().replace(REGEX.whitespace, " ");
}
function dataURIPayload(string) {
  return encodeURIComponent(string).replace(REGEX.urlHexPairs, specialHexEncode);
}
function colorCodeToShorterNames(string) {
  objectKeys(shorterNames).forEach((key) => {
    if (shorterNames[key].test(string)) {
      string = string.replace(shorterNames[key], key);
    }
  });
  return string;
}
function specialHexEncode(match3) {
  switch (match3) {
    case "%20":
      return " ";
    case "%3D":
      return "=";
    case "%3A":
      return ":";
    case "%2F":
      return "/";
    default:
      return match3.toLowerCase();
  }
}
function svgToDataUri(svgString) {
  if (typeof svgString !== "string") {
    throw new TypeError("Expected a string, but received " + typeof svgString);
  }
  if (svgString.charCodeAt(0) === 65279) {
    svgString = svgString.slice(1);
  }
  const body = colorCodeToShorterNames(collapseWhitespace(svgString)).replace(REGEX.quotes, "'");
  return "data:image/svg+xml," + dataURIPayload(body);
}
var objectKeys = (obj) => Object.keys(obj);

// src/transform.ts
function toUnit(v) {
  return isCssUnit(v) || hasReference(v.toString()) ? v : `${v}px`;
}
function px(v) {
  return isString(v) ? v : `${v}px`;
}
var transformShadow = {
  name: "tokens/shadow",
  match: (token) => token.extensions.category === "shadows",
  transform(token, dict) {
    if (isString(token.value)) {
      return token.value;
    }
    if (Array.isArray(token.value)) {
      return token.value.map((value) => this.transform({ value }, dict)).join(", ");
    }
    if (isCompositeShadow(token.value)) {
      const { offsetX, offsetY, blur, spread, color, inset } = token.value;
      return [inset ? "inset " : "", px(offsetX), px(offsetY), px(blur), px(spread), color].filter(Boolean).join(" ");
    }
    return token.value;
  }
};
var transformGradient = {
  name: "tokens/gradient",
  match: (token) => token.extensions.category === "gradients",
  transform(token) {
    if (isString(token.value)) {
      return token.value;
    }
    if (isCompositeGradient(token.value)) {
      const { type, stops, placement } = token.value;
      const rawStops = stops.map((stop) => {
        if (isString(stop))
          return stop;
        const { color, position } = stop;
        return `${color} ${position}px`;
      });
      return `${type}-gradient(${placement}, ${rawStops.join(", ")})`;
    }
    return token.value;
  }
};
var transformFonts = {
  name: "tokens/fonts",
  match: (token) => token.extensions.category === "fonts",
  transform(token) {
    if (Array.isArray(token.value)) {
      return token.value.join(", ");
    }
    return token.value;
  }
};
var transformEasings = {
  name: "tokens/easings",
  match: (token) => token.extensions.category === "easings",
  transform(token) {
    if (isString(token.value)) {
      return token.value;
    }
    if (Array.isArray(token.value)) {
      return `cubic-bezier(${token.value.join(", ")})`;
    }
    return token.value;
  }
};
var transformBorders = {
  name: "tokens/borders",
  match: (token) => token.extensions.category === "borders",
  transform(token) {
    if (isString(token.value)) {
      return token.value;
    }
    if (isCompositeBorder(token.value)) {
      const { width, style, color } = token.value;
      return `${toUnit(width)} ${style} ${color}`;
    }
    return token.value;
  }
};
var transformAssets = {
  name: "tokens/assets",
  match: (token) => token.extensions.category === "assets",
  transform(token) {
    const raw = token.value;
    return match(raw).with(P2.string, (value) => value).with({ type: "url" }, ({ value }) => `url("${value}")`).with({ type: "svg" }, ({ value }) => `url("${svgToDataUri(value)}")`).exhaustive();
  }
};
var transformColorMix = {
  name: "tokens/color-mix",
  match: (token) => {
    return token.extensions.category === "colors" && token.value.includes("/");
  },
  transform(token, dict) {
    if (!token.value.includes("/"))
      return token;
    return expandReferences(token.value, (path) => {
      const tokenFn = (tokenPath) => {
        const token2 = dict.getByName(tokenPath);
        return token2?.extensions.varRef;
      };
      const mix = dict.colorMix(path, tokenFn);
      if (mix.invalid) {
        throw new Error("Invalid color mix at " + path + ": " + mix.value);
      }
      return mix.value;
    });
  }
};
var addCssVariables = {
  type: "extensions",
  name: "tokens/css-var",
  transform(token, dictionary) {
    const { prefix, hash } = dictionary;
    const { isNegative, originalPath } = token.extensions;
    const pathValue = isNegative ? originalPath : token.path;
    const variable = dictionary.formatCssVar(pathValue.filter(Boolean), { prefix, hash });
    return {
      var: variable.var,
      varRef: variable.ref
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  name: "tokens/conditionals",
  transform(token, dictionary) {
    const { prefix, hash } = dictionary;
    const refs = getReferences(token.value);
    if (!refs.length)
      return token.value;
    const modifier = refs.some((ref) => ref.includes("/"));
    if (!modifier) {
      refs.forEach((ref) => {
        const variable = dictionary.formatCssVar(ref.split("."), { prefix, hash }).ref;
        token.value = token.value.replace(`{${ref}}`, variable);
      });
    } else {
      const tokenFn = (name) => {
        const token2 = dictionary.getByName(name);
        return token2?.extensions.varRef;
      };
      token.value = expandReferences(token.value, (path) => {
        const mix = dictionary.colorMix(path, tokenFn);
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      });
    }
    return token.value;
  }
};
var addColorPalette = {
  type: "extensions",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors" && !token.extensions.isVirtual;
  },
  transform(token, dict) {
    let tokenPathClone = [...token.path];
    tokenPathClone.pop();
    tokenPathClone.shift();
    if (tokenPathClone.length === 0) {
      const newPath = [...token.path];
      newPath.shift();
      tokenPathClone = newPath;
    }
    if (tokenPathClone.length === 0) {
      return {};
    }
    const colorPaletteRoots = tokenPathClone.reduce(
      (acc, _, i, arr) => {
        const next = arr.slice(0, i + 1);
        acc.push(next);
        return acc;
      },
      []
    );
    const colorPaletteRoot = tokenPathClone[0];
    const colorPalette = dict.formatTokenName(tokenPathClone);
    const colorPaletteTokenKeys = token.path.slice(token.path.indexOf(colorPaletteRoot) + 1).reduce(
      (acc, _, i, arr) => {
        acc.push(arr.slice(i));
        return acc;
      },
      []
    );
    if (colorPaletteTokenKeys.length === 0) {
      colorPaletteTokenKeys.push([""]);
    }
    return {
      colorPalette,
      colorPaletteRoots,
      colorPaletteTokenKeys
    };
  }
};
var transforms = [
  transformShadow,
  transformGradient,
  transformFonts,
  transformEasings,
  transformBorders,
  transformAssets,
  addCssVariables,
  transformColorMix,
  // depends on `addCssVariables`
  addConditionalCssVariables,
  addColorPalette
];

// src/expand-token-references.ts
import { esc as esc2 } from "@pandacss/shared";
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state = "char";
  let tokenPath = "";
  let fallback = "";
  const currentStates = [];
  while (index < str.length) {
    const char = str[index];
    if (char === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state === "token") {
      if (char === ",") {
        if (str[index] === "") {
          index++;
        }
        state = "fallback";
        currentStates.push(state);
        const resolved = resolve(tokenPath);
        if (resolved?.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback = "";
        continue;
      }
    }
    if (state === "fallback") {
      const nextFallback = fallback + char;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state = currentStates.pop() ?? state;
        fallback = "";
        continue;
      }
    }
    if (state === "token" || state === "fallback") {
      index++;
      if (char === ")") {
        state = currentStates.pop() ?? state ?? "char";
        fallback += char;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback) {
          fallback = fallback.slice(1).trim();
          if (!fallback.startsWith("token(") && fallback.endsWith(")")) {
            fallback = fallback.slice(0, -1);
          }
          if (fallback.includes("token(")) {
            const parsed = expandTokenReferences(fallback, resolve);
            if (parsed) {
              fallback = parsed.slice(0, -1);
            }
          } else if (fallback) {
            const resolvedFallback = resolve(fallback);
            if (resolvedFallback) {
              fallback = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback) {
          if (lastChar?.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback + ")");
          } else {
            expanded += fallback;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback = "";
        state = "char";
        continue;
      }
      if (state === "token") {
        tokenPath += char;
      }
      if (state === "fallback") {
        fallback += char;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state = "token";
      currentStates.push(state);
      continue;
    }
    expanded += char;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char = str[index];
    if (char === "(") {
      openedParenthesises.push(char);
    } else if (char === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// src/dictionary.ts
function expandBreakpoints(breakpoints) {
  if (!breakpoints)
    return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints, (value) => ({ value })),
    sizes: Object.fromEntries(Object.entries(breakpoints).map(([key, value]) => [`breakpoint-${key}`, { value }]))
  };
}
function filterDefault(path) {
  if (path[0] === "DEFAULT")
    return path;
  return path.filter((item) => item !== "DEFAULT");
}
var TokenDictionary = class {
  constructor(options) {
    this.options = options;
  }
  allTokens = [];
  byName = /* @__PURE__ */ new Map();
  deprecated = /* @__PURE__ */ new Set();
  init() {
    this.registerTokens();
    this.registerTransform(...transforms);
    this.registerMiddleware(...middlewares);
    this.build();
    return this;
  }
  get prefix() {
    return this.options.prefix;
  }
  get hash() {
    return this.options.hash;
  }
  getByName = (path) => {
    return this.byName.get(path);
  };
  formatTokenName = (path) => path.join(".");
  formatCssVar = (path, options) => cssVar(path.join("-"), options);
  registerTokens() {
    const { tokens = {}, semanticTokens = {}, breakpoints, themes = {} } = this.options;
    const breakpointTokens = expandBreakpoints(breakpoints);
    const computedTokens = compact({
      ...tokens,
      breakpoints: breakpointTokens.breakpoints,
      sizes: {
        ...tokens.sizes,
        ...breakpointTokens.sizes
      }
    });
    const processToken = (token, path) => {
      const isDefault = path.includes("DEFAULT");
      path = filterDefault(path);
      assertTokenFormat(token);
      const category = path[0];
      const name = this.formatTokenName(path);
      const node = new Token({ ...token, name, path });
      node.setExtensions({
        category,
        prop: this.formatTokenName(path.slice(1))
      });
      if (isDefault) {
        node.setExtensions({ isDefault });
      }
      return node;
    };
    const processSemantic = (token, path) => {
      const isDefault = path.includes("DEFAULT");
      path = filterDefault(path);
      assertTokenFormat(token);
      const category = path[0];
      const name = this.formatTokenName(path);
      const normalizedToken = isString2(token.value) || isCompositeTokenValue(token.value) ? { value: { base: token.value } } : token;
      const { value, ...restData } = normalizedToken;
      const node = new Token({
        ...restData,
        name,
        value: value.base || "",
        path
      });
      node.setExtensions({
        category,
        conditions: value,
        prop: this.formatTokenName(path.slice(1))
      });
      if (isDefault) {
        node.setExtensions({ isDefault });
      }
      return node;
    };
    walkObject2(
      computedTokens,
      (token, path) => {
        const node = processToken(token, path);
        this.registerToken(node);
      },
      { stop: isToken }
    );
    walkObject2(
      semanticTokens,
      (token, path) => {
        const node = processSemantic(token, path);
        this.registerToken(node);
      },
      { stop: isToken }
    );
    Object.entries(themes).forEach(([theme, themeVariant]) => {
      const condName = "_theme" + capitalize(theme);
      walkObject2(
        themeVariant.tokens ?? {},
        (token, path) => {
          const themeToken = { value: { [condName]: token.value } };
          const node = processSemantic(themeToken, path);
          node.setExtensions({ theme, isVirtual: true });
          this.registerToken(node);
        },
        { stop: isToken }
      );
      walkObject2(
        themeVariant.semanticTokens ?? {},
        (token, path) => {
          const themeToken = { value: { [condName]: token.value } };
          const node = processSemantic(themeToken, path);
          node.setExtensions({ theme, isSemantic: true, isVirtual: true });
          this.registerToken(node);
        },
        { stop: isToken }
      );
    });
    return this;
  }
  registerToken = (token, transformPhase) => {
    this.allTokens.push(token);
    this.byName.set(token.name, token);
    if (token.deprecated) {
      this.deprecated.add(token.name);
    }
    if (transformPhase) {
      this.transforms.forEach((transform) => {
        if (transform.enforce === transformPhase) {
          this.execTransformOnToken(transform, token);
        }
      });
    }
  };
  transforms = /* @__PURE__ */ new Map();
  registerTransform(...transforms2) {
    transforms2.forEach((transform) => {
      transform.type ||= "value";
      transform.enforce ||= "pre";
      this.transforms.set(transform.name, transform);
    });
    return this;
  }
  execTransform(name) {
    const transform = this.transforms.get(name);
    if (!transform)
      return;
    this.allTokens.forEach((token) => {
      this.execTransformOnToken(transform, token);
    });
  }
  execTransformOnToken(transform, token) {
    if (token.extensions.hasReference)
      return;
    if (typeof transform.match === "function" && !transform.match(token))
      return;
    const exec = (v) => transform.transform(v, this);
    const transformed = exec(token);
    match2(transform).with({ type: "extensions" }, () => {
      token.setExtensions(transformed);
    }).with({ type: "value" }, () => {
      token.value = transformed;
      if (token.isComposite) {
        token.originalValue = transformed;
      }
      if (token.extensions.conditions) {
        const conditions = token.extensions.conditions;
        const transformedConditions = walkObject2(conditions, (value) => exec({ value }), {
          stop: isCompositeTokenValue
        });
        token.setExtensions({
          conditions: transformedConditions
        });
      }
    }).otherwise(() => {
      token[transform.type] = transformed;
    });
  }
  transformTokens(enforce) {
    this.transforms.forEach((transform) => {
      if (transform.enforce === enforce) {
        this.execTransform(transform.name);
      }
    });
    return this;
  }
  middlewares = [];
  registerMiddleware(...middlewares2) {
    for (const middleware of middlewares2) {
      middleware.enforce ||= "pre";
      this.middlewares.push(middleware);
    }
    return this;
  }
  applyMiddlewares(enforce) {
    this.middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(this);
      }
    });
  }
  getReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref) => this.getByName(ref)).filter(Boolean);
  }
  usesReference(value) {
    if (!isString2(value))
      return false;
    return this.getReferences(value).length > 0;
  }
  addReferences() {
    this.allTokens.forEach((token) => {
      if (!this.usesReference(token.value))
        return;
      const references = this.getReferences(token.value);
      token.setExtensions({
        references: references.reduce(
          (object, reference) => {
            object[reference.name] = reference;
            return object;
          },
          {}
        )
      });
    });
    return this;
  }
  filter(pattern) {
    const predicate = typeof pattern === "function" ? pattern : isMatching2(pattern);
    return this.allTokens.filter(predicate);
  }
  addConditionalTokens() {
    this.allTokens.forEach((token) => {
      const conditionalTokens = token.getConditionTokens();
      if (conditionalTokens && conditionalTokens.length > 0) {
        conditionalTokens.forEach((token2) => {
          this.registerToken(token2);
        });
      }
    });
    return this;
  }
  expandTokenReferences() {
    this.allTokens.forEach((token) => {
      token.expandReferences();
    });
    return this;
  }
  colorMix = (value, tokenFn) => {
    if (!value || typeof value !== "string")
      return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = this.getByName(`opacity.${rawOpacity}`)?.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  /**
   * Expand token references to their CSS variable
   */
  expandReferenceInValue(value) {
    return expandTokenReferences(value, (path) => {
      if (!path)
        return;
      if (path.includes("/")) {
        const mix = this.colorMix(path, this.view.get.bind(this.view));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = this.view.get(path);
      if (resolved)
        return resolved;
      return tokenPathRegex.test(path) ? esc3(path) : path;
    });
  }
  /**
   * Get the value of a token reference
   */
  resolveReference(value) {
    return expandReferences(value, (key) => this.getByName(key)?.value);
  }
  /**
   * Resolve token references to their actual raw value (recursively resolves references)
   */
  deepResolveReference(originalValue) {
    const stack = [originalValue];
    while (stack.length) {
      const next = stack.pop();
      if (next.startsWith("{")) {
        stack.push(this.resolveReference(next));
        continue;
      }
      if (next.startsWith("var(")) {
        const ref = this.view.nameByVar.get(next);
        if (ref) {
          stack.push(this.resolveReference(`{${ref}}`));
          continue;
        }
      }
      return next;
    }
  }
  isDeprecated(name) {
    return this.deprecated.has(name);
  }
  build() {
    this.applyMiddlewares("pre");
    this.transformTokens("pre");
    this.addConditionalTokens();
    this.addReferences();
    this.expandTokenReferences();
    this.applyMiddlewares("post");
    this.transformTokens("post");
    this.setComputedView();
    return this;
  }
  get isEmpty() {
    return this.allTokens.length === 0;
  }
  view;
  setComputedView() {
    this.view = new TokenDictionaryView(this).getTokensView();
    return this;
  }
};
var TokenDictionaryView = class {
  constructor(dictionary) {
    this.dictionary = dictionary;
    this.dictionary = dictionary;
  }
  getTokensView() {
    const conditionMap = /* @__PURE__ */ new Map();
    const categoryMap = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    const valuesByCategory = /* @__PURE__ */ new Map();
    const flatValues = /* @__PURE__ */ new Map();
    const nameByVar = /* @__PURE__ */ new Map();
    const vars = /* @__PURE__ */ new Map();
    this.dictionary.allTokens.forEach((token) => {
      this.processCondition(token, conditionMap);
      this.processColorPalette(token, colorPalettes, this.dictionary.byName);
      this.processCategory(token, categoryMap);
      this.processValue(token, valuesByCategory, flatValues, nameByVar);
      this.processVars(token, vars);
    });
    const json = mapToJson(valuesByCategory);
    return {
      conditionMap,
      categoryMap,
      colorPalettes,
      vars,
      values: flatValues,
      nameByVar,
      json,
      valuesByCategory,
      get: memo((path, fallback) => {
        return flatValues.get(path) ?? fallback;
      }),
      getCategoryValues: memo((category) => {
        const result = json[category];
        if (result != null) {
          return result;
        }
      })
    };
  }
  processCondition(token, group) {
    const { condition } = token.extensions;
    if (!condition)
      return;
    if (!group.has(condition))
      group.set(condition, /* @__PURE__ */ new Set());
    group.get(condition).add(token);
  }
  processColorPalette(token, group, byName) {
    const extensions = token.extensions;
    const { colorPalette, colorPaletteRoots, isVirtual } = extensions;
    if (!colorPalette || isVirtual)
      return;
    colorPaletteRoots.forEach((colorPaletteRoot) => {
      const formated = this.dictionary.formatTokenName(colorPaletteRoot);
      if (!group.has(formated)) {
        group.set(formated, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette([...token.path], [...colorPaletteRoot]);
      const virtualName = this.dictionary.formatTokenName(virtualPath);
      const virtualToken = byName.get(virtualName);
      if (!virtualToken)
        return;
      const virtualVar = virtualToken.extensions.var;
      group.get(formated).set(virtualVar, token.extensions.varRef);
      if (extensions.isDefault && colorPaletteRoot.length === 1) {
        const colorPaletteName = this.dictionary.formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = byName.get(colorPaletteName);
        if (!colorPaletteToken)
          return;
        const name = this.dictionary.formatTokenName(token.path);
        const virtualToken2 = byName.get(name);
        if (!virtualToken2)
          return;
        const keyPath = extensions.colorPaletteTokenKeys[0]?.filter(Boolean);
        if (!keyPath.length)
          return;
        const formated2 = this.dictionary.formatTokenName(colorPaletteRoot.concat(keyPath));
        if (!group.has(formated2)) {
          group.set(formated2, /* @__PURE__ */ new Map());
        }
        group.get(formated2).set(colorPaletteToken.extensions.var, virtualToken2.extensions.varRef);
      }
    });
  }
  processCategory(token, group) {
    const { category, prop } = token.extensions;
    if (!category)
      return;
    if (!group.has(category))
      group.set(category, /* @__PURE__ */ new Map());
    group.get(category).set(prop, token);
  }
  processValue(token, byCategory, flatValues, nameByVar) {
    const { category, prop, varRef, isNegative } = token.extensions;
    if (!category)
      return;
    if (!byCategory.has(category))
      byCategory.set(category, /* @__PURE__ */ new Map());
    const value = isNegative ? token.extensions.condition !== "base" ? token.originalValue : token.value : varRef;
    byCategory.get(category).set(prop, value);
    flatValues.set(token.name, value);
    nameByVar.set(value, token.name);
  }
  processVars(token, group) {
    const { condition, isNegative, isVirtual, var: varName, theme } = token.extensions;
    if (isNegative || !theme && isVirtual || !condition)
      return;
    if (!group.has(condition))
      group.set(condition, /* @__PURE__ */ new Map());
    group.get(condition).set(varName, token.value);
  }
};
function replaceRootWithColorPalette(path, colorPaletteRoot) {
  const startIndex = path.findIndex(
    (element, index) => colorPaletteRoot.every((rootElement, rootIndex) => path[index + rootIndex] === rootElement)
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, colorPaletteRoot.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenPathRegex = /\w+\.\w+/;
export {
  Token,
  TokenDictionary,
  assertTokenFormat,
  expandReferences,
  getReferences,
  hasReference,
  isToken,
  mapToJson
};
