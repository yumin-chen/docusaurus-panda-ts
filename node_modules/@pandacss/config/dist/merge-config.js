"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/merge-config.ts
var merge_config_exports = {};
__export(merge_config_exports, {
  mergeConfigs: () => mergeConfigs
});
module.exports = __toCommonJS(merge_config_exports);
var import_shared2 = require("@pandacss/shared");
var import_merge_anything = require("merge-anything");

// src/merge-hooks.ts
var import_logger = require("@pandacss/logger");
var mergeHooks = (plugins) => {
  const hooksFns = {};
  plugins.forEach(({ name, hooks }) => {
    Object.entries(hooks ?? {}).forEach(([key, value]) => {
      if (!hooksFns[key]) {
        hooksFns[key] = [];
      }
      hooksFns[key].push([name, value]);
    });
  });
  const mergedHooks = Object.fromEntries(
    Object.entries(hooksFns).map(([key, entries]) => {
      const fns = entries.map(([name, fn]) => tryCatch(name, fn));
      const reducer = key in reducers ? reducers[key] : void 0;
      if (reducer) {
        return [key, reducer(fns)];
      }
      return [key, syncHooks.includes(key) ? callAll(...fns) : callAllAsync(...fns)];
    })
  );
  return mergedHooks;
};
var createReducer = (reducer) => reducer;
var reducers = {
  "config:resolved": createReducer((fns) => async (_args) => {
    const args = Object.assign({}, _args);
    const original = _args.config;
    let config = args.config;
    for (const hookFn of fns) {
      const result = await hookFn(Object.assign(args, { config, original }));
      if (result !== void 0) {
        config = result;
      }
    }
    return config;
  }),
  "parser:before": createReducer((fns) => (_args) => {
    const args = Object.assign({}, _args);
    const original = _args.content;
    let content = args.content;
    for (const hookFn of fns) {
      const result = hookFn(Object.assign(args, { content, original }));
      if (result !== void 0) {
        content = result;
      }
    }
    return content;
  }),
  "parser:preprocess": createReducer((fns) => (_args) => {
    const args = Object.assign({}, _args);
    const original = _args.data;
    let data = args.data;
    for (const hookFn of fns) {
      const result = hookFn(Object.assign(args, { data, original }));
      if (result !== void 0) {
        data = result;
      }
    }
    return data;
  }),
  "cssgen:done": createReducer((fns) => (_args) => {
    const args = Object.assign({}, _args);
    const original = _args.content;
    let content = args.content;
    for (const hookFn of fns) {
      const result = hookFn(Object.assign(args, { content, original }));
      if (result !== void 0) {
        content = result;
      }
    }
    return content;
  }),
  "codegen:prepare": createReducer((fns) => async (_args) => {
    const args = Object.assign({}, _args);
    const original = _args.artifacts;
    let artifacts = args.artifacts;
    for (const hookFn of fns) {
      const result = await hookFn(Object.assign(args, { artifacts, original }));
      if (result) {
        artifacts = result;
      }
    }
    return artifacts;
  })
};
var syncHooks = [
  "context:created",
  "parser:before",
  "parser:preprocess",
  "parser:after",
  "cssgen:done"
];
var callAllAsync = (...fns) => async (...a) => {
  for (const fn of fns) {
    await fn?.(...a);
  }
};
var callAll = (...fns) => (...a) => {
  fns.forEach((fn) => fn?.(...a));
};
var tryCatch = (name, fn) => {
  return (...args) => {
    try {
      return fn(...args);
    } catch (e) {
      import_logger.logger.error("hooks", `The error below comes from the plugin ${name}`);
      console.error(e);
    }
  };
};

// src/validation/utils.ts
var import_shared = require("@pandacss/shared");
var isValidToken = (token) => (0, import_shared.isObject)(token) && Object.hasOwnProperty.call(token, "value");

// src/merge-config.ts
function getExtends(items) {
  return items.reduce((merged, { extend }) => {
    if (!extend)
      return merged;
    return (0, import_shared2.mergeWith)(merged, extend, (originalValue, newValue) => {
      if (newValue === void 0) {
        return originalValue ?? [];
      }
      if (originalValue === void 0) {
        return [newValue];
      }
      if (Array.isArray(originalValue)) {
        return [newValue, ...originalValue];
      }
      return [newValue, originalValue];
    });
  }, {});
}
function mergeRecords(records) {
  return {
    ...records.reduce((acc, record) => (0, import_shared2.assign)(acc, record), {}),
    extend: getExtends(records)
  };
}
function mergeExtensions(records) {
  const { extend = [], ...restProps } = mergeRecords(records);
  return (0, import_shared2.mergeWith)(restProps, extend, (obj, extensions) => {
    return (0, import_merge_anything.mergeAndConcat)({}, obj, ...extensions);
  });
}
var isEmptyObject = (obj) => typeof obj === "object" && Object.keys(obj).length === 0;
var compact = (obj) => {
  return Object.keys(obj).reduce((acc, key) => {
    if (obj[key] !== void 0 && !isEmptyObject(obj[key])) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
};
var tokenKeys = ["description", "extensions", "type", "value", "deprecated"];
function mergeConfigs(configs) {
  const userConfig = configs.at(-1);
  const pluginHooks = userConfig.plugins ?? [];
  if (userConfig.hooks) {
    pluginHooks.push({ name: import_shared2.PANDA_CONFIG_NAME, hooks: userConfig.hooks });
  }
  const reversed = Array.from(configs).reverse();
  const mergedResult = (0, import_shared2.assign)(
    {
      conditions: mergeExtensions(reversed.map((config) => config.conditions ?? {})),
      theme: mergeExtensions(reversed.map((config) => config.theme ?? {})),
      patterns: mergeExtensions(reversed.map((config) => config.patterns ?? {})),
      utilities: mergeExtensions(reversed.map((config) => config.utilities ?? {})),
      globalCss: mergeExtensions(reversed.map((config) => config.globalCss ?? {})),
      globalVars: mergeExtensions(reversed.map((config) => config.globalVars ?? {})),
      globalFontface: mergeExtensions(reversed.map((config) => config.globalFontface ?? {})),
      globalPositionTry: mergeExtensions(reversed.map((config) => config.globalPositionTry ?? {})),
      staticCss: mergeExtensions(reversed.map((config) => config.staticCss ?? {})),
      themes: mergeExtensions(reversed.map((config) => config.themes ?? {})),
      hooks: mergeHooks(pluginHooks)
    },
    ...reversed
  );
  const withoutEmpty = compact(mergedResult);
  if (withoutEmpty.theme?.tokens) {
    (0, import_shared2.walkObject)(withoutEmpty.theme.tokens, (args) => args, {
      stop(token) {
        if (!isValidToken(token))
          return false;
        const keys = Object.keys(token);
        const nestedKeys = keys.filter((k) => !tokenKeys.includes(k));
        const nested = nestedKeys.length > 0;
        if (nested) {
          token.DEFAULT ||= {};
          tokenKeys.forEach((key) => {
            if (token[key] == null)
              return;
            token.DEFAULT[key] ||= token[key];
            delete token[key];
          });
        }
        return true;
      }
    });
  }
  return withoutEmpty;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  mergeConfigs
});
