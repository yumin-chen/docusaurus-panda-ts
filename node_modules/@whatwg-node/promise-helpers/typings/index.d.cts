export type MaybePromise<T> = Promise<T> | T;
export type MaybePromiseLike<T> = PromiseLike<T> | T;
export declare function isPromise<T>(value: MaybePromise<T>): value is Promise<T>;
export declare function isPromise<T>(value: MaybePromiseLike<T>): value is PromiseLike<T>;
export declare function handleMaybePromise<TInput, TOutput>(inputFactory: () => MaybePromise<TInput>, outputSuccessFactory: (value: TInput) => MaybePromise<TOutput>, outputErrorFactory?: (err: any) => MaybePromise<TOutput>): MaybePromise<TOutput>;
export declare function handleMaybePromise<TInput, TOutput>(inputFactory: () => MaybePromiseLike<TInput>, outputSuccessFactory: (value: TInput) => MaybePromiseLike<TOutput>, outputErrorFactory?: (err: any) => MaybePromiseLike<TOutput>): MaybePromiseLike<TOutput>;
export declare function fakePromise<T>(value: T): Promise<T>;
export declare function fakePromise(value: void): Promise<void>;
export interface DeferredPromise<T = void> {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason: any) => void;
}
export declare function createDeferredPromise<T = void>(): DeferredPromise<T>;
export declare function iterateAsyncVoid<TInput>(iterable: Iterable<TInput>, callback: (input: TInput, stopEarly: () => void) => MaybePromise<void>): MaybePromise<void>;
export declare function fakeRejectPromise(error: unknown): Promise<never>;
/**
 * @deprecated Use `handleMaybePromise` instead.
 */
export declare function mapMaybePromise<TInput, TOutput>(input: MaybePromise<TInput>, onSuccess: (value: TInput) => MaybePromise<TOutput>, onError?: (err: any) => MaybePromise<TOutput>): MaybePromise<TOutput>;
export declare function mapMaybePromise<TInput, TOutput>(input: MaybePromiseLike<TInput>, onSuccess: (value: TInput) => MaybePromiseLike<TOutput>, onError?: (err: any) => MaybePromiseLike<TOutput>): MaybePromiseLike<TOutput>;
/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */
export declare function mapAsyncIterator<T, U>(iterator: AsyncIterable<T> | AsyncIterator<T>, onNext: (value: T) => MaybePromise<U>, onError?: any, onEnd?: () => MaybePromise<void>): AsyncIterableIterator<U>;
